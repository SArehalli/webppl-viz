/*
  (local-set-key (kbd "s-r") (lambda () (interactive) (save-buffer) (process-send-string "*shell viz*" "echo '\n'; webppl src/multi.wppl\n")))
*/

var mappingSamplers = {
  freqtable: function(fieldTypes) {
    // assumes 0 r
    var n = _.size(fieldTypes), fields = _.keys(fieldTypes), types = _.pluck(fieldTypes, 'type');

    // TODO: sample a permutation of fields

    var d = {
      '1': ['col'],
      '2': ['col','row'],
      '3': ['col','row','facetCol'],
      '4': ['col','row','facetCol','facetRow']
    }

    return _.object(fields, d[n + '']);
  },
  hist: function(fieldTypes) {
    var n = _.size(fieldTypes), fields = _.keys(fieldTypes), types = _.pluck(fieldTypes, 'type');

    if (n == 1) {
      // TODO: possibly use color?
      return _.object(fields, ['x'])
    } else if (n == 2) {
      return _.object(fields, ['x', uniformDraw(['color','facetCol'])])
    } else if (n == 3) {
      return _.object(fields, ['x', 'color', 'facetCol']);
    } else if (n == 4) {
      return _.object(fields, ['x','color','facetCol', 'facetRow']);
    } else {
      console.log("too many fields");
      return process.exit();
    }
  },
  scatter: function(fieldTypes) {
    // TODO: do something different for 1r versus 2r
  }
}

var getColumnType = function(columnValues) {
  // for now, support real, integer, and categorical
  // some questions:
  // - can we support list of reals a la dirichlet?
  // - would knowing type information from the forward model (e.g., foo ~ multinomial([a,b,c])) help?
  if (_.every(columnValues, _.isNumber)) {
    return _.every(columnValues, Number.isInteger) ? 'c' : 'r'
  } else {
    return 'c'
  }
};

var getColumnTypes = function(df) {
  var columnNames = _.keys(df[0]);
  return _.object(
    columnNames,
    map(function(name) {
      if (name == '__prob__') {
        return 'real'
      } else {
        return getColumnType(_.pluck(df, name));
      }
    }, columnNames)
  )
};

var sampleGraph = function(distDf) {
  // get types for every column except __prob__
  var fieldTypes = _.omit(getColumnTypes(distDf), '__prob__'),
      types = _.values(fieldTypes);

  var nR = filter(function(t) { return t == 'r' }, types).length;

  var possibleMarks = [
    ['freqtable','hist'],  // 0 r
    ['scatter','density'], // 1 r
    ['scatter','heat'],    // 2 r
    ['parcoords']          // 3 r
  ][nR > 3 ? 3 : nR];

  var mark = uniformDraw(possibleMarks);
  condition(mark == 'hist')

  // sample mappings for this mark
  var mappingSampler = mappingSamplers[mark],
      mappings = mappingSampler(fieldTypes);

  // make vega spec
  var specMaker = specMakers[mark],
      spec = specMaker(mappings, distDf);

  /* conditions:
     - prefer colors over facet cols
     - prefer facet cols over facet rows
     - prefer fewer colors
  */

  var out = {mark: mark,
             mappings: mappings,
             spec: spec};
  return out;
};

var specMakers = {
  hist: function(_mappings /* logical -> physical */, _distDf) {
    var k = _.size(_mappings);
    var _mappingsI = _.invert(_mappings); // physical -> logical

    var presentAesthetics = _.keys(_mappingsI),
        missingAesthetics = _.difference(['x','facetRow','facetCol','color'], presentAesthetics);

    // add dummy columns (facetRow, facetCol, or color) to mappings dictionaries

    var facetLogicalNames = {facetRow: 'gy', facetCol: 'gx', color: 'gc'};

    var mappings = _.extend(_.object(map(function(name) { return [facetLogicalNames[name], name]  },
                                missingAesthetics)),
                            _mappings);
    var mappingsI = _.invert(mappings);

    // add dummy columns to data
    var distDf = missingAesthetics.length == 0
        ? _distDf
        : map(function(row) {
          var dummyCols = _.object(map(function(name) { return [facetLogicalNames[name], 'dummy']  }, missingAesthetics))
          _.extend(dummyCols, row) },
              _distDf);

    // start building spec from the bottom up

    var xSource = mappingsI.x;
    var colorSource = mappingsI.color;

    var marks2 = [
      {name: 'marks2',
       type: 'rect',
       from: {data: 'raw'},
       properties: {
         update: {
           x:     {scale: 'colorPosScale', field: colorSource},
           width: {scale: 'colorPosScale', band: true, offset: 0},
           y:     {scale: 'probScale', field: '__prob__'},
           y2:    {scale: 'probScale', value: 0},
           fill:  {scale: 'colorColorScale', field: colorSource}
         }
       }
      }
    ];

    var marks1 = [
      {name: 'marks1',
       type: 'group',
       from: {
         transform: [{type: "facet",groupby: xSource}]
       },
       properties: {
         enter: {
           x: {scale: "xScale",field: "key"},
           width: {scale: "xScale",band: true}
         }
       },
       scales: [{
         "name": "colorPosScale",
         "type": "ordinal",
         "domain": {"field": colorSource},
         "range": "width"
       }],
       marks: marks2
      }
    ];

    var marks0 = [
      {name: 'marks0',
       type: 'group',
       properties: {
         update: {
           x: {scale: "gx",field: mappingsI.facetCol},
           y: {scale: "gy",field: mappingsI.facetRow},
           width: {scale: "gx", band: true, offset: 0},
           height: {scale: "gy", band: true, offset: 0},
           stroke: {value: "#ccc"},
           strokeWidth: {value: 1}
         }
       },
       from: {
         data: "raw",
         transform: [{type: "facet",groupby: [mappingsI.facetRow, mappingsI.facetCol]}]
       },
       scales: [
         {
           name: "xScale",
           type: "ordinal",
           domain: {field: xSource},
           range: "width",
           padding: 0.2
         },
         {
           name: "probScale",
           type: "linear",
           domain: {field: "__prob__"}, // TODO: make a random choice between data domain and [0,1]?
           range: "height"
         },
         {
           name: "colorColorScale",
           type: "ordinal",
           domain: {field: colorSource},
           range: "category10"
         }
       ],
       axes: [
         {type: "y", scale: "probScale", title: "Probability"},
         {type: "x", scale: "xScale", title: xSource}
       ],
       marks: marks1
      }
    ];

    var facetScales = [
      {
        name: 'gx',
        type: 'ordinal',
        domain: {data: 'raw', field: mappingsI.facetCol},
        range: 'width',
        padding: 0.1
      },
      {
        name: 'gy',
        type: 'ordinal',
        domain: {data: 'raw', field: mappingsI.facetRow},
        range: 'height',
        padding: 0.1
      }
    ];

    // TODO: hide facet Axes for dummy values
    var facetAxes = [
      {
        type: "y",
        scale: "gy",
        orient: "left",
        tickSize: 0,
        title: mappingsI.facetRow,
        properties: {axis: {strokeWidth: {value: 1}}}
      },
      {
        type: "x",
        scale: "gx",
        tickSize: 0,
        title: mappingsI.facetCol,
        properties: {
          axis: {strokeWidth: {value: 1}},
          title: {angle: 0}
        }
      }
    ];

    var viz = {
      data: [{"name": "raw", "values": distDf}],
      scales: facetScales,
      axes: facetAxes,
      marks: marks0
    };

    return viz;
  }
}



var multi = function(dist) {
  // convert distribution to a dataframe including a __prob__  column
  var distDf = map(function(x) { _.extend({__prob__: Math.exp(dist.score(x))}, x)},
                   dist.support())

  // sample an abstract graph based on the data
  var graphDist = Rejection(function() {  sampleGraph(distDf) } );

  // convert the abstract graph into a full vega spec
  var spec = graphDist.support()[0].spec;
  return spec;
}

util.seedRNG(3)

var posterior = Enumerate(function() {
  return {a: flip(0.6) ? 'foo' : 'bar',
          b: flip(0.7) ? 'baz' : 'quux'
         }
})



JSON.stringify(multi(posterior),null,1)
